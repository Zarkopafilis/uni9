    /* grid graphs */
    // std::cout << "Grid Graphs" << std::endl << std::endl;
    // int grid_n = {100, 200, 300};
    // for (int l = 0; l < 3; l++)
    // {
    //     int k = grid_n[l]; // grid size
    //     std::cout << "Grid (" << k << "," << k << ")" << std::endl;
    //     std::cout << "Constructing Graph" << std::endl;

    //     /* START BOILERPLATE */

    //     /* END BOILERPLATE */

    //     int num_nodes = k * k;
        
    //     leda::node node_tracker[num_nodes];

    //     // populate vertices
    //     for (int x = 0; x < k; x++)
    //     {
    //         for (int y = 0; y < k; y++)
    //         {
    //             int cur = x * k + y;
    //             node_tracker[cur] = LG.new_node();
    //         }
    //     }

    //     // populate edges
    //     for (int x = 0; x < k; x++)
    //     {
    //         for (int y = 0; y < k; y++)
    //         {
    //             // node index calculation
    //             int cur = x * k + y;

    //             if (y < k / 2)
    //             { // top part | bottom and right
    //                 if (x != k - 1)
    //                 { // not rightmost limit
    //                     // connect to right (x, y) -> (x + 1, y)
    //                     int trg_right = (x + 1) * k + y;
    //                     int w_right = S() % 10000;

    //                     edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_right]);
    //                     l_weight[e] = w_right;
    //                 }

    //                 // connect to bottom (x, y) -> (x, y + 1)
    //                 int trg_bot = x * k + y + 1;
    //                 int w_bot = S() % 10000;
    //                 edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_bot]);
    //                 l_weight[e] = w_bot;
    //             }
    //             else if (y == k / 2)
    //             { // middle row | only right
    //                 if (x != k - 1)
    //                 { // not rightmost limit
    //                     // connect to right (x, y) -> (x + 1, y)
    //                     int trg = (x + 1) * k + y;
    //                     int w = S() % 10000;

    //                     edge e = LG.new_edge(node_tracker[cur], node_tracker[trg]);
    //                     l_weight[e] = w;
    //                 }
    //             }
    //             else
    //             { // bottom part
    //                 if (x < k / 2)
    //                 { // bottom left
    //                     if (y == (k / 2) + 1 && x == (k / 2) - 1)
    //                     { // special target
    //                         int w_spec = -100000;
    //                         int trg_spec = x * k + (y - 1);
                            
    //                         edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_spec]);
    //                         l_weight[e] = w_spec;
    //                     }

    //                     // random direction
    //                     // random left
    //                     if (x != 0)
    //                     { // not leftmost
    //                         int randomval = rand() % 2;
    //                         if (randomval == 1){
    //                             int w_l = (S() % (10000 + 100)) - 100 int trg_l = (x - 1) * k + y;
    //                             int trg_l = (x - 1) * k + y;

    //                             edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_l]);
    //                             l_weight[e] = w_l;
    //                         }
    //                     }

    //                     // random bottom
    //                     if (y != k - 1)
    //                     { // not bottom most
    //                         int randomval = rand() % 2;
    //                         if (randomval == 1){
    //                             int w_b = (S() % (10000 + 100)) - 100;
    //                             int trg_b = x * k + y + 1;

    //                             edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_b]);
    //                             l_weight[e] = w_b;
    //                         }
    //                     }

    //                     // random up
    //                     int randomval = rand() % 2;
    //                     if (randomval == 1){
    //                         int w_u = (S() % (10000 + 100)) - 100 int trg_u = x * k + y - 1;
    //                         int trg_u = x * k + y - 1;

    //                         edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_u]);
    //                         l_weight[e] = w_u;
    //                     }
    //                     // random right
    //                     int randomval = rand() % 2;
    //                     if (randomval == 1){
    //                         int w_r = (S() % (10000 + 100)) - 100 int trg_r = (x + 1) * k + y;
    //                         int trg_r = (x + 1) * k + y;

    //                         edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_r]);
    //                         l_weight[e] = w_r;
    //                     }
    //                 }
    //                 else if (x == k / 2)
    //                 { // center bottom column
    //                     int trg_bot = x * k + y + 1;
    //                     int w_bot = S() % 10000;

    //                     edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_bot]);
    //                     l_weight[e] = w_bot;

    //                     if (y == (k / 2) + 1)
    //                     { // special target
    //                         int w_spec = -100000;
    //                         int trg_spec = (x - 1) * k + y;

    //                         edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_spec]);
    //                         l_weight[e] = w_spec;
    //                     }
    //                 }
    //                 else
    //                 { // bottom right
    //                     if (x == k - 1)
    //                     {
    //                         continue; // last node
    //                     }

    //                     if (y != k - 1)
    //                     { // if not bottom most
    //                         int trg_bot = x * k + y + 1;
    //                         int w_bot = S() % 10000;
                            
    //                         edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_bot]);
    //                         l_weight[e] = w_bot;
    //                     }

    //                     // connect to right (x, y) -> (x + 1, y)
    //                     int trg_r = (x + 1) * k + y;
    //                     int w_r = S() % 10000;

    //                     edge e = LG.new_edge(node_tracker[cur], node_tracker[trg_r]);
    //                     l_weight[e] = w_r;
    //                 }
    //             }
    //         }
    //     } // end populate edges

    //     int source_idx = 0;
    //     nodeInfo[source_idx] = 0; // start node

    //     std::cout << "Copying to BGL" << std::endl;
    //     copy_graph(LG, BG, l_weight, b_weight, nodeInfo, b_dist, b_visit);

    //     std::cout << "Running Benchmarks" << std::endl;
    //     benchmark();
    //}